#coding=utf-8
__author__ = 'egor'

"""
Script parameters:
    1: tag - file tag (all files related to quality check are named with the same tag)
    2: l - low bound for neutral cut
    3: r - upper bound for neutral cut
    4: pairs index - index of pairs file
"""

import sys
    
def read_to_dict(dict_to_add, filename):
    f = open(filename, 'r', encoding="utf-8")
    for s in f:
        if s.strip(' \n') not in dict_to_add:
            dict_to_add[s.strip(' \n')] = 0
    f.close()

def read_sums(sums_dict, filename):
    f = open(filename, 'r', encoding="utf-8")
    for s in f:
        s_split = s.strip(' \n').split(' ')
        if s_split[0] not in sums_dict:
            sums_dict[s_split[0]] = float(s_split[1])
    f.close()

def get_quality(new_pos, new_neg, new_neu):
    big_pos_file = "../../testing/big_pos.txt"
    big_neg_file = "../../testing/big_neg.txt"
    big_neu_file = "../../testing/big_neu.txt"
    big_pos = {}
    big_neg = {}
    big_neu = {}
    read_to_dict(big_pos, big_pos_file)
    read_to_dict(big_neg, big_neg_file)
    read_to_dict(big_neu, big_neu_file)
    
    # words, not found in big dict
    not_found = []
    for w in new_pos:
        if not (w in big_pos or w in big_neg or w in big_neu):
            not_found.append(w)
    for w in new_neg:
        if not (w in big_pos or w in big_neg or w in big_neu):
            not_found.append(w)
    for w in new_neu:
        if not (w in big_pos or w in big_neg or w in big_neu):
            not_found.append(w)
            
    # calculating quality
    pos_true = 0 # number of guessed positive words
    neg_true = 0 # number of guessed positive words
    pos_false = 0 # number of mistakes (negative word recognized as positive)
    neg_false = 0 # number of mistakes (positive word recognized as negative)
    neu_false = 0 # neuatral, recognized not as neutral
    mistake_dict = {} # rude mistakes
    # iterating through words from generated by algorithms dictionary and counting guessed words.	
    for w in new_pos:
        if w in big_pos:
            pos_true += 1
        elif w in big_neg:
            mistake_dict[w] = 1
            neg_false += 1
        elif w in big_neu:
            neu_false += 1

    for w in new_neg:
        if w in big_neg:
            neg_true += 1
        elif w in big_pos:
            mistake_dict[w] = -1
            pos_false += 1
        elif w in big_neu:
            neu_false += 1
    rude_mist_perc = (len(mistake_dict) *  100)/ (neg_false + pos_false + neu_false)
    quality = (pos_true + neg_true) * 100 / (len(new_pos) + len(new_neg))
    res = {"q":quality, "mistakes":mistake_dict, "pt":pos_true, 
    "pf":pos_false, "nt":neg_true, "nf":neg_false, "nef":neu_false,
    "notfound":not_found, "rude":rude_mist_perc}
    return res
    

if __name__ == "__main__":
    if len(sys.argv) < 4:
        sys.exit("Bad arguments! Usage: [file tag] [low bound] [up bound]")
    
    # reading parameters
    
    ftag = sys.argv[1]
    l = float(sys.argv[2])
    r = float(sys.argv[3])
    
    # files names to read from

    new_pos_file = "../results/pos" + ftag + ".txt"
    new_neg_file = "../results/neg" + ftag + ".txt"
    new_neu_file = "../results/neu" + ftag + ".txt"

    sums_file = "../results/weights/sums" + ftag + ".txt"

    # initializing dictionaries
    new_pos = {}
    new_neg = {}
    new_neu = {}

    sums_dict = {} # distance to pos minus distance to neg for words

    transformed_dict = {} # words, which appeared with 'не' prefix

    # reading dictionaries
    read_to_dict(new_pos, new_pos_file)
    read_to_dict(new_neg, new_neg_file)

    # reading weights to pos and neg parts for every word from new dictionaries
    read_sums(sums_dict, sums_file)

    print ("New pos: " + str(len(new_pos)))
    print ("New neg: " + str(len(new_neg)))
    print ("New neu: " + str(len(new_neu)))

    # cutting neutral part
    for w in new_pos:
        if l <= sums_dict[w] <= r:
            new_neu[w] = 0
            
    for w in new_neg:
        if l <= sums_dict[w] <= r:
            new_neu[w] = 0
            
    for w in new_neu:
        if w in new_pos:
            del new_pos[w]
        elif w in new_neg:
            del new_neg[w]

    print ("After cut pos: " + str(len(new_pos)))
    print ("After cut neg: " + str(len(new_neg)))
    print ("After cut neu: " + str(len(new_neu)))

    qr = get_quality(new_pos, new_neg, new_neu)
    print("Not found:")
    print(qr["notfound"])
    print("True positive = " + str(qr["pt"]))
    print("True negative = " + str(qr["nt"]))
    print("False positive = " + str(qr["pf"]))
    print("False negative = " + str(qr["nf"]))
    print("False neutral = " + str(qr["nef"]))
    print("Quality = " + str(qr["q"]) + " %")
    
    mistake_dict = qr["mistakes"]
    # outputting mistakes
    f = open("mistakes_qual" + ftag + ".txt", "w", encoding="utf-8")
    for w in mistake_dict:
        f.write(w + "\n")
    f.close()
